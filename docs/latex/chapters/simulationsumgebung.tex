\chapter{Simulationsumgebung}

Um eine Simulation in einem geeigneten zeitlichen Rahmen erstellen zu können, bietet sich die Verwendung von einer Simulationsumgebung an. Diese enthält hauptsächlich ein Framework mit vielen Bibliotheken, welche für den speziellen Anwendungsfall viel Arbeit ersparen können. \newline
Es gibt eine große Auswahl an verschiedenen Simulationsumgebungen, wobei jede ihre Vor- und Nachteile mit sich bringt. Wichtig für die Arbeit ist ein Simulator der Netzwerke bereitstellt und auch drahtlose Kommunikation ermöglicht. Es sollten eigene Knoten erstellt und angepasst werden können, damit die Hardwaresensorik und das Verhalten im Umgang mit Nachrichten untereinander genau definiert werden können. Auch Funktionen für die Repräsentation von Batterieeigenschaften und die Erfassung und Analyse von Statistiken sollten vorhanden sein.\newline
Im Falle von speziellen Anforderungen der Frameworks sollte eine IDE vorhanden sein, die diese unterstützt. Auch eine sehr wichtige Anforderung an den Simulator ist eine grafische Umgebung für die Simulation selbst, sodass Informationen nicht nur aus Dateien ausgelesen werden können, sondern für den Nutzer auch auf den ersten Blick sichtbar sind.

\section{wichtige Simulationsumgebungen}

Es gibt viele Umgebungen zum Simulieren von Netzwerken. Zunächst werden hier 4 Wichtige vorgestellt: die \textbf{IKR Simulation Library (IKR SimLib)} von der Universität Stuttgart, der \textbf{Open Source Wireless Network Simulator} kurz \textbf{openWNS} von der Universität Aachen, \textbf{ns-3} vom ns-3 project und \textbf{Simanet} von der TU Chemnitz.

\paragraph{Simulation Library (IKR SimLib)\cite{ikr}}

Eine freie Simulationsbibliothek unter der Lizenz GNU LGPL für Kommunikationsnetzwerke in C++ und Java von der Universität Stuttgart. Diese steht für Linux und Unix(-artige) Systeme zur Verfügung, während die Verwendung unter Windows nicht offiziell getestet wurde.\newline
Da es lediglich eine Bibliothek für Java darstellt, existieren keine extra IDE und auch keinerlei GUI oder ähnliche Hilfswerkzeuge. Allerdings kann ein Projekt mit jeder normalen Java- oder C++ IDE benutzt werden, schließlich muss nur die Bibliothek importiert werden.\newline
Da schon seit den 1980ern an IKR SimLib entwickelt wird, kann die Bibliothek weitreichende Funktionalitäten zur Verfügung stellen, wie zum Beispiel Unterstützung für mobile, IP- oder P2P-Netzwerke.

\paragraph{openWNS\cite{openwns}}

OpenWNS ist ein Simulator für kabellose Kommunikation, entwickelt von der Universität Aachen. Das Projekt steht kostenlos zur Nutzung bereit und ist mit der LGPLv2 lizensiert. \newline
Es wurde speziell für Linux entwickelt, es läuft allerdings auch unter Windows. Die Entwicklung erfolgt in Python. Für grafische Unterstützung sorgt das integrierte Tool Wrowser\cite{wrowser}, welches in erster Linie dazu dient die Resultate der Simulation zu sammeln und die Messwerte zu visualisieren, aber auch beim Erstellen einer Simulation Hilfestellungen bietet, wie beispielsweise beim Einrichten der Simulationsdatenbank.\newline
Es gibt keine extra für openWNS erstellte oder angepasste IDE, allerdings wird in der Dokumentation beschrieben, wie der Texteditor Emacs\cite{emacs} den speziellen Anforderungen vom openWNS-Stil angepasst werden kann. Allerdings ist es notwendig für die Entwicklung stets einen Texteditor, den Wrowser und die Kommandozeile zu benutzen, was im Vergleich zu einer alles umfassenden IDE deutlich weniger komfortabel ist.

\paragraph{NS-3\cite{ns3}}

ns-3 ist ein freier Netzwerksimulator, der unter der GPLv2 lizensiert ist. Das Erstellen der Simulationen funktioniert mithilfe der Sprache Python. Dafür steht keine extra IDE zur Verfügung, was allerdings auch nicht notwenig ist, da es genügend andere Python-Umgebungen gibt.\newline
Es werden sowohl kabelgebundene als auch kabellose Verbindungen unterstützt. Allerdings besteht nicht für alle wichtigen Protokolle eine Unterstützung, wie beispielsweise WSN.\newline
Ein weiterer großer Nachteil ist, dass es keine Oberfläche während der Ausführung gibt. Die Simulation wird per Textausgabe auf der Kommandozeile ausgeführt. Die gesammelten Daten können anschließend mit Plot-Tools visualisiert werden. Für das Generieren von Netzwerken steht jedoch ein grafisches Hilfsmittel zur Verfügung. Mit dem Topology Generator\cite{TopGen} können per GUI Netzwerke angelegt werden und anschließend in C++ oder Python-Code umgewandelt werden. 

\paragraph{Simanet\cite{simanet}}

Simanet ist ein Projekt, welches an der TU Chemnitz entstanden ist. Es eignet sich sehr gut für das Simulieren von Funkkommunikation und daher zum Testen von Routingverfahren.\\
Im Vergleich zu anderen Simulatoren wie Omnet++ oder ns-3 ist Simanet sehr leichtgewichtig und eignet sich daher hervorragend für sehr große Simulationen.\\
Es gibt zahlreiche vorhandene Module, die wichtige Funkstandards wie WLAN oder ZigBee, Energiemodelle, Lokalisierung und auch Visualisierung und Auswertung abdecken.

\paragraph{Omnet++\cite{omnet}}

Omnet++ ist ein Framework für die Simulation von Netzwerken, welches unter der ACADEMIC PUBLIC LICENSE steht. Die Nutzung ist daher kostenfrei und der Quellcode ist offen und darf verändert werden.\\
Es bietet eine angepasste IDE, welche die Besonderheiten der NED-Sprache und auch den C++-Code interpretieren kann.\\Die Simulation selbst bietet ein grafisches Interface und auch für die Auswertung von statistischen Daten stehen grafische Hilfsmittel innerhalb der IDE bereit.\\
Der größte Vorteil von Omnet++ ist die Möglichkeit, Code auf dem Application Layer der Sensorknoten ausführen zu können, was bei vielen andern Simulatoren nicht möglich ist.\\
Funkkommunikation ist standardmäßig in Omnet++ zwar nicht möglich, aber durch das MiXiM-Framework wird diese implementiert.

\paragraph{weitere}

Es gibt natürlich außer den bisher genannten Simulationsumgebungen auch noch weitere, auf die hier aber nicht näher eingegangen werden soll. So gibt es beispielsweise GloMoSim, welches die parallele Programmiersprache Parsec benutzt. Es ist geeignet um sowohl kabellose, als auch -gebundene Netzwerke zu simulieren, jedoch wird es zum aktuellen Stand nicht mehr weiterentwickelt. \newline
Eine weitere Alternative wäre NetSim, welches von Tetcos, zusammen mit dem Indian Institute of Science entwickelt wurde. Die bestehenden Bibliotheken sind in C geschrieben und implementieren viele Protokolle wie beispielsweise WLAN, TCP oder LTE.

\section{Vergleich}

Simanet unterstützt leider keine komplexe Codeausführung innerhalb von Netzwerkknoten. Es ist daher für diese Arbeit nicht geeignet, da das Verhalten der Sensorik nicht abgebildet werden kann. Daher wird Simanet im folgenden Vergleich nicht weiter berücksichtigt. 

\begin{table}[!ht]
  \centering
  \caption{Übersicht Simulatoren}
  \label{Übersicht Simulatoren}
\begin{tabularx}{\textwidth}{lllll}
	\toprule
	& Omnet++ & IKR SimLib & OpenWNS & NS-3 \\
	\midrule
	\specialcell{freie Lizenz}  & \cmark & \cmark(LGPL) & \cmark (LGPLv2) & \cmark (GPLv2) \\
	\specialcell{alle gängigen\\Betriebssysteme} & \cmark & \specialcell{kein\\Windows} & \cmark & \specialcell{kein\\Windows} \\
	\specialcell{GUI bei Simulation} & \cmark & \xmark & (\cmark) & \xmark \\
	IDE & \cmark & (\xmark) & (\xmark) & (\cmark) \\
	Drahtlose Verb. & (\cmark) mit MiXiM & \cmark & \cmark & \cmark \\
	Sprache(n) & C++ mit NED & C++ oder Java & Python & Python \\
	\bottomrule
\end{tabularx}
\end{table}

In Tabelle \ref{Übersicht Simulatoren} ist ein direkter Vergleich der größten Unterschiede zwischen den Simulatoren Omnet++, IKR SimLib, OpenWNS und NS-3 aufgezeigt. Es ist sehr positiv zu bewerten, dass alle Simulationsumgebungen über freie Lizenzen verfügen und die für die Arbeit relevante drahtlose Kommunikation ermöglichen.\newline
Der größte Nachteil der Simulatoren IKR SimLib und ns-Simulator liegt darin, dass beide keine grafische Umgebung für die Simulation selbst bieten. Das wirkt sich wiederum natürlich positiv auf die Performanz aus, allerdings lässt sich über eine grafische Übersicht deutlich leichter und schneller ein Eindruck über die Zustände der Simulation gewinnen. Ein weiterer Nachteil der beiden ist die eingeschränkte Verfügbarkeit auf verschiedenen Betriebssystemen. \newline
OpenWNS bietet nur teilweise Unterstützung in grafischer Hinsicht. Es ist möglich mithilfe des sogenannten Wrowser die Simulation zu starten und die statistischen Daten zu erfassen. Jedoch bietet es keine so umfassende Oberfläche wie Omnet++. \newline
Letztendlich ist die Entscheidung zugunsten von Omnet++ gefallen. Die Simulationsumgebung wird im folgenden Abschnitt ausführlicher beschrieben.

\section{Omnet++}

\subsection{Einleitung}

Omnet++\cite{omnet} ist eine C++-Bibliothek und ein C++-Framework, welches primär zum Simulieren von Netzwerken dient. Außerdem bietet es eine Netzwerkbeschreibungssprache namens NED (NEtwork Description) und eine auf Eclipse\cite{eclipse} basierende Entwicklungsumgebung. Für die Simulation besteht außerdem ein grafisches Interface, mit dem die Kommunikation der Knoten im Netzwerk gut verfolgt werden kann.
\newline Standardmäßig werden keine mobilen oder kabellosen Protokolle in Omnet++ unterstützt. Jedoch kann mithilfe des MiXiM-Frameworks die Funktionalität um eben diese erweitert werden.
\newline Es bietet unterstützt alle gängigen Betriebssysteme wie Linux, andere unixbasierte Systeme, Mac OS und Windows und besitzt außerdem eine kostenlose Lizenz.

\begin{figure}[htbp]
\centering
\caption{GUI bei der Ausführung einer Simulation }
\label{fig:messageEvent}
\includegraphics[width=\textwidth]{SimulationUI}
\end{figure}

\subsection{NED language}

Die Netzwerkbeschreibungssprache NED\cite{ned} bietet eine Möglichkeit, auch komplexe Netzwerke relativ einfach zu beschreiben und darzustellen. Man kann schnell ein einfaches Modul mit Gates (siehe Listing \ref{lst:simpleNode}) für die Kommunikation beschreiben oder ihm Submodule für verschiedene andere Aufgaben zuweisen und dieses in ein Netzwerk integrieren und dort mehrere und auch verschiedene Instanzen von Modulen verknüpfen (siehe Listing \ref{lst:simpleNetwork}).
\newline
Dabei helfen die verschiedenen möglichen Module. Es können die 3 Typen simple, module und network definiert werden. Wie der Name schon sagt, ist network dazu da ein Netzwerk zu beschreiben und sollte alle nötigen Module als Submodule beinhalten. 
\newline
Mit dem Schlüsselwort module lassen sich komplexe Objekte beschreiben. Neben den Standardvariablen wie beispielsweise Parameter, Gates oder Connections lassen sich auch Submodule definieren. Dadurch ist es möglich verschiedene in sich abgeschlossene Modulteile in einem großen Modul zu vereinen.
\newline
Geeignet als ein solches Modulteil ist wiederum das simple-Modul. Dieses kann keine weiteren Submodule besitzen, sondern lediglich einfache Funktionalität definieren.\\
Wenn nicht anders über den Parameter @class angegeben sucht \textbf{Omnet++} nach einer Klasse, die den gleichen Namen wie das erstellte Modul besitzt. In dieser können Funktionen deklariert und implementiert werden, die das Verhalten des Moduls beeinflusst. Welche Funktionen von \textbf{Omnet++} interpretiert werden, wird im Kapitel \ref{para:Nodes and Messages} näher erklärt.
Eine Übersicht mit Kurzbeschreibung zu den wichtigsten Schlüsselwörtern in NED in der Tabelle \ref{tab:NED} zu finden.

\begin{table}[!ht]
  \centering
  \caption{NED Schlüsselbegriffe}
\begin{tabularx}{\textwidth}{lll}
	\toprule
	Kategorie & Begriffe & Funktion \\
	\midrule
	\multirow{6}{*}{Modulart} & network & ein Netzwerk, 1 pro Simulation\\
	& simple & ein einfaches, eigenständiges Modul\\
	& module & ein compound Modul, kann Submodule haben\\
	& channel & beschreibt eine Verbindung zwischen Gates\\
	& channelinterface & ein Interface für Channel\\
	& moduleinterface & ein Interface für Module\\
	\midrule
	\multirow{5}{*}{\specialcell{Sections\\von\\Modulen}} & types & um eigene Typen im Modul zu definieren\\
	& parameters & Parameter des Moduls definieren\\
	& submodules & andere Module integrieren\\
	& gates & Schnittstellen für Kommunikation definieren\\
	& connections & Gates miteinander verbinden\\
	\midrule
	\multirow{3}{*}{Typen} & \multicolumn{2}{l}{int, string, double, bool}\\
	& xmldoc & speichert den Pfad eines XML-Files\\
	& xml	 & speichert XML\\
	\midrule
	\multirow{5}{*}{Verbindungen} & allowunconnected & \specialcell{erlaubt Kommunikation zwischen Gates \\ohne definierte Verbindung}\\
	& input & definiert ein Gate als eingehend\\
	& output & definiert ein Gate als ausgehend\\
	& inout & legt je ein in- und output Gate an\\
	\midrule
	\multirow{7}{*}{weitere} & @display & Eigenschaften zur Darstellung bei Sim.\\
	& @class & spezielle C++-Klasse zum Modul definieren \\
	&package & definiert den Namensraum\\	
	& import & andere Pakete und Module einbinden\\
	&\multicolumn{2}{l}{volatile, const, extends,import,like}\\
	&\multicolumn{2}{l}{this,false,true,default, if,and,or,else,for}\\
	&\multicolumn{2}{l}{index,sizeof,typename}\\
	\bottomrule
\end{tabularx}
\label{tab:NED}
\end{table}

\begin{figure}[htbp]
\centering
\caption{Oberfläche der Entwicklungsumgebung mit Bespiel für die NED-Integration}
\label{fig:messageEvent}
\includegraphics[width=\textwidth]{omnetEclipse}
\end{figure}

\paragraph{Beispiel} Ein kurzes Beispiel soll das Zusammenspiel einiger wichtiger Schlüsselworte aufzeigen:

Zunächst wird ein einfach Modul (Listing \ref{lst:simpleNodeLed}) erstellt, welches eine LED repräsentiert. Dieses erhält dafür einen Parameter vom Typ boolean, welcher anzeigt, ob die LED leuchtet und einen eingehenden Port, welcher die Lampe steuern kann. 
\begin{lstlisting}[language=ned,caption={einfaches Modul: LED},label=lst:simpleNodeLed]
simple LED
{
	parameters:
		bool ledLeuchtet;
	gates:
		input control;
}
\end{lstlisting}

Als zweites Modul, ebenso wie die LED vom Typ simple, wird ein einfach Knopf (Listing \ref{lst:simpleNodeButton}) definiert. Dieser hat ein input-Gate über welches einen Knopfdruck simulieren kann und ein ausgehendes Gate, welches im Falle eines Knopfdrucks ein Signal ausgeben kann.
\begin{lstlisting}[language=ned,caption={einfaches Modul: Knopf},label=lst:simpleNodeButton]
simple Knopf
{
	gates:
		input buttonStateChange;
		output signal;
}
\end{lstlisting}

Als drittes wird ein Modul vom Typ module definiert (Listing \ref{lst:simpleNode}). Es handelt sich dabei um ein Compound-Modul. Dieses kann genutzt werden, um verschiedene simple-Module auf sich zu vereinen und die Interaktion zwischen diesen zu ermöglichen. So können komplexe Bauteile modular definiert werden.\\
Das Modul repräsentiert einen Bauteil, welches einen Knopf und eine LED besitzt. Zusätzlich besitzt es ein eingehendes und ein ausgehendes Gate. Das output-Gate vom Knopf ist mit dem eingehendes Gate von der LED verbunden, den durch einen Knopfdruck soll die LED ein- oder ausgeschaltet werden können.
\begin{lstlisting}[language=ned,caption={Compound Modul},label=lst:simpleNode]
module Knoten
{
	parameters:
		string name="KnotenMitLedUndKnopf";
	submodules:
		Blinker: LED {
		}
		Button: Knopf {
		}
	gates:
		input in;
		output out;
	connections:
		Button.signal --> Blinker.control;
}
\end{lstlisting}

Da es sich in Omnet++ um eine Netzwerksimulation handelt, wird einschließend noch ein kleines Netzwerk aus den vorher definierten Modulen aufgebaut werden (Listing \ref{lst:simpleNetwork}). Dabei werden zwei Module vom Typ Knoten erstellt und die jweiligen Gates der Beiden miteinander verbunden.
\begin{lstlisting}[language=ned,caption={einfaches Netzwerk},label=lst:simpleNetwork]
network Netzwerk
{
	submodules:
		node1: Knoten;
		node2: Knoten;
	connections:
		node1.in <-- node2.out;
		node1.out --> node2.in;
}
\end{lstlisting}

\subsection{Einige Techniken, Funktionen und wichtige Module}

Im folgenden Abschnitt wird ein Ausschnitt darüber gegeben, was Omnet++ an Funktionalitäten bereitstellt. Grundlegend wird für eine einfache Simulation ein Netzwerk benötigt, welches in der Netzwerkbeschreibungssprache NED beschrieben wird. Dieses Netzwerk kann dann Nodes definieren, welche selbst Module sind, welche wiederum auch in NED beschrieben werden. Wenn diese Module ausgehende und/oder eingehende Gates besitzen, können diese im Netzwerk wiederum miteinander verbunden werden.\newline
Dieser einfache Grundaufbau genügt im Prinzip schon, damit eine valide Simulation ablaufen kann. Um dazu noch etwas Funktionalität in die Module zu bringen ist es möglich, für jedes Modul eine Klasse in C++ zu definieren. Man kann zum einen eigene Klassen definieren oder die in der Simulationsbibliothek vorhandenen Klassen nutzen.\newline
Zusätzlich zur Standardbibliothek gibt es noch 3 relevante Frameworks, die weitere Funktionen zur Verfügung stellen: MiXiM, INET und Castalia.

\subsubsection{Nodes and Messages}\label{para:Nodes and Messages}

Für die Steuerung innerhalb einer Simulation sind Nachrichten das wichtigste Werkzeug in \textbf{Omnet++}. So kann man eine Nachricht zu einer festgelegten Simulationszeit verschicken, um diese als Events einzusetzen. Dabei können Knoten auch Nachrichten an sich selbst versenden.

Um einem selbst definierten Modul die Möglichkeit zu geben Nachrichten zu verstehen und zu benutzen werden einige Funktionen bereitgestellt, die man selbst definieren muss.

Diese sind für die Funktionalität eines \textbf{cSimpleModule} entscheidend und sollten nach dem Erstellen eines neuen Moduls implementiert werden:

\begin{itemize}
\item void initialize()
\item void handleMessage(cMessage *msg)
\item void activity()
\item void finish()
\end{itemize}

\paragraph{initialize()}

Die Funktion \textbf{initialize()} wird nach dem Erstellen eines Moduls aufgerufen. Es kann so ähnlich wie ein Konstruktor verwendet werden. Entscheidend ist, dass die Methode erst aufgerufen wird, nachdem auch der \textbf{NED}-Teil des Moduls eingelesen wurde. Das bedeutet, dass erst an dieser Stelle auf Parameter des Moduls zugegriffen werden kann und das ist im Konstruktor noch nicht möglich. Auch Nachrichten kann das Modul erst ab diesem Zeitpunkt verschicken.

\paragraph{handleMessage(cMessage *msg)}

Diese Methode kann eingehende Nachrichten auswerten. Sollten bei einem Modul Nachrichten ankommen, ohne dass diese Funktion definiert wurde, wird ein Fehler auftreten. Wie Nachrichten genauer aufgebaut sind, ist im Abschnitt \textbf{cMessage} beschrieben.
Nachrichten können zeitgesteuert Events auslösen. Die Methode \textbf{handleMessage()} ist somit das Herzstück der meisten Module, da hier das komplette Verhalten geregelt wird. \newline
Es können im Regelfall natürlich viele verschiedene Arten von Nachrichten in einem Modul eintreffen, die auch unterschiedlich behandelt werden müssen. Zur Fallunterscheidung stehen wiederum viele Funktion im Nachrichtenmodul zur Verfügung, die beispielsweise Informationen über den Sender liefer, ob die Nachricht eine Selfmessage war, also vom Modul an sich selbst gesendet wurde oder einfache Informationen wie der Name der Nachricht.

\paragraph{activity()}

Diese Methode ist eine eher unwichtige Funktion. Wenn \textbf{handleMessage()} korrekt verwendet wird, sollte man auf die Benutzung von \textbf{activity()} am besten komplett verzichten. Es verhält sich oberflächlich betrachtet wie \textbf{handleMessage()}, allerdings wird diese Methode nicht einfach aufgerufen, sollte eine Nachricht ankommen, sondern läuft in einer Endlosschleife und wartet Permanet aktiv auf Nachrichten. Daher ist sie wesentlich rechenintensiver als das Gegenstück \textbf{handleMessage()}.

\paragraph{finish()}

Diese Methode wird aufgerufen, nachdem die Simulation beendet wurde und noch bevor das Modul gelöscht wurde. Sie sollte nicht zum Löschen anderer Module verwendet werden, da nach dem Aufruf von finish() die Simulation erneut gestartet werden kann, ohne dass das Netzwerk komplett neu initialisiert wird. Wenn allerdings wichtige Module an dieser Stelle gelöscht wurden, ist ein Neustart nicht mehr möglich.\newline
Die Methode ist stattdessen dafür da die eben abgelaufene Simulation auszuwerten. Es können an dieser Stelle alle relevanten Informationen gespeichert werden, damit diese hinterher statistisch ausgewertet werden können.

\subsubsection{cMessage}

Für die Nachrichten selbst existiert ein fertig implementiertes Modul namens \textbf{cMessage}. Dieses erfüllt schon die wichtigsten Anforderungen, die man an ein Nachrichtenmodul stellt. So können Nachrichten nicht nur \textbf{strings} übertragen, sondern alle Klassen, die von \textbf{cNamedObject} erben. Man kann also auch komplexe, selbst definierte Objekte mithilfe von cMessage übertragen.\\
Es empfiehlt sich dennoch eine eigene Kindklasse von cMessage zu definieren, da man in diesem eigene Parameter definieren kann, die verschiedene Werte beschreiben. So kann man zum Beispiel genauere Informationen für Quelle und Senke in der Nachricht speichern oder verschiedene Werte für Statistiken. Sollte man eine veränderte Kindklasse von cMessage definieren, so wird zusätzlich eine Klasse dazu generiert, die viele Funktionen bereitstellt, die zum Beispiel das Kopieren einer Nachricht ermöglichen - auch inklusive der extra hinzugefügten Parameter.

\begin{table}[!ht]
  \centering
  \caption{Übersicht über einige Funktionen von cMessage}
\begin{tabularx}{\textwidth}{rll}
	\toprule
	typ & Funktion & Kurzbeschreibung\\
	\midrule	
	virtual cArray \& & getParList () & Parameterliste einer Nachricht\\
	bool 	& isSelfMessage () const & ist Nachricht an sich selbst\\
	cModule * 	& getSenderModule () const & \multirow{4}{*}{\specialcell{Informationen über Sender\\äquivalent für Arrival vorhanden}} \\
	cGate * 	& getSenderGate () const  & \\
	int &	getSenderModuleId () const & \\
	int &	getSenderGateId () const & \\
	simtime\_t\_cref 	& getCreationTime () const & Zeitpunkt: Nachricht erstellt\\
	simtime\_t\_cref 	& getSendingTime () const & Zeitpunkt: Nachricht gesendet\\
	simtime\_t\_cref 	& getArrivalTime () const  & Zeitpunkt: Nachricht angekommen\\
	bool &	arrivedOn (int gateId) const & Id des Inputgate\\
	\bottomrule
\end{tabularx}
\end{table}

\subsubsection{XML Support}

NED-Parameter eines Moduls können vom Typ xml sein. Die dazu gehörende Klasse cXMLElement bietet ihrerseits umfangreiche Unterstützung dafür an. Diese orientiert sich dabei an einem DOM-Parser, ist allerdings aus Performanzgründen nur ähnlich aufgebaut. Dabei stellt die Klasse die für X-Path typischen Funktionen für XML-Zugriffe bereit wie zum Beispiel \textbf{getParentNode()} oder \textbf{getChildren()}.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=C++,caption={Beispiel einlesen von XML},label=lst:xml]
cXMLElement *rootE = par("xmlFile").xmlValue();
cXMLElementList nListRows = rootE->getChildren();
int amountRows = nListRows.size();
int* data = new int[amountRows];
for (int i = 0; i < amountRows; i++){
    //nListRowArray ist eine Zeile aus dem XML file 
    //bzw. alle Elemente 1. Ebene unter der Wurzel
    cXMLElement* nListRowArray = nListRows[i];
    //kann ab hier beliebig tief fortgesetzt werden
}
\end{lstlisting}
\end{minipage}

\subsubsection{Statistiken}

Um die durchgeführten Simulationen ordentlich auswerten zu können, stellt Omnet++ verschiedene Werkzeuge bereit. Neben dem Eventlog ist es möglich, während der Simulation Skalar- sowie Vektorwerte zu definieren. Die Skalarwerte besitzen dabei einen fixen Wert, wogegen Vektoren die Veränderung von bestimmten Variablen im Laufe der Simulationszeit speichern können. Die dazugehörigen Klassen heißen cLongHistogram und cOutVector.\\
Diese beiden Werte können nach dem erfolgreichen Abschließen einer Simulation auch grafisch ausgewertet werden. Dazu kann nach dem Exportieren der Werte in der Simulationsumgebung ausgewählt werden, welche Daten zusammen in einem Diagramm dargestellt werden sollen. Zum Erstellen der Graphen wird Gnuplot\cite{gnuplot} genutzt. Anschließend können noch verschiedene Einstellungen getroffen werden, damit die Daten möglichst gut visualisiert werden können. Beispielsweise kann der Typ des Kurvenverlaufs gewählt werden. In den Bildern \ref{fig:statRight} und \ref{fig:statWrong} ist ein Beispiel dafür. Es liegt ein Automat vor, welcher zwischen 3 Zuständen wechselt. Dabei zeigt\ref{fig:statRight} die wesentlich besser Variante des Graphen.

\begin{figure}[htbp]
\centering
\caption{Zustandswechsel Automat falsch}
\label{fig:statWrong}
\includegraphics[width=\textwidth]{statWrong}
\end{figure}

\begin{figure}[htbp]
\centering
\caption{Zustandswechsel Automat richtig}
\label{fig:statRight}
\includegraphics[width=\textwidth]{statRight}
\end{figure}

\subsubsection{weitere Beispiele}

\paragraph{cClassDescriptor} Eine Klasse, die dabei behilflich ist, die Felder eines Objektes zu finden. Dazu muss eine Klasse lediglich von cClassDescriptor erben. Die Verwendung funktioniert wie im Listing \ref{lst:cclassdescriptor} beschrieben. 

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=C++,caption={Verwendung von cClassDescriptor },label=lst:cclassdescriptor]
cClassDescriptor* thisDescr = cClassDescriptor::getDescriptorFor(this);
int count = thisDescr->getFieldCount(this);

for ( int i = 0; i < count; i++) {
    std::stringstream s;
    s << i <<" " << thisDescr->getFieldName(this, i) << " " ;
    s << thisDescr->getFieldAsString(this, i, 0);
    s << i << " " << thisDescr->getFieldName(this, i);
    cMessage *msg = new cMessage(s.str().c_str());
    send(msg, "gate$o");
}
\end{lstlisting}
\end{minipage}

\paragraph{Simulationszeit und Events}

Die Zeit einer Simulation verläuft linear. Anhand dieser kann die Ausführung von Events für einen bestimmten Zeitpunkt geplant werden. Dies ist möglich durch das Versenden von cMessage in Kombination mit einer Scheduletime und wenn nötig als Selfmessage.\\
Wenn ein Modul einen Zeitraum der Ausführung abgeschlossen hat, soll es unter Umständen eingefroren werden und erst zu einem späteren Zeitpunkt reaktiviert werden. Damit es in dieser Zeit nicht aktiv warten muss und somit unnötig Prozessorlast oder im Fall von mobilen Geräten auch noch zusätzlich Energie verbraucht, kann ein Modul jegliche Aktionen unterlassen, bis eine Nachricht, wie ein Event, die weitere Ausführung wieder anstößt (siehe Abbildung \ref{fig:messageEvent}). 

\begin{figure}[htbp]
\centering
\caption{Beispiel cMessage als Event}
\label{fig:messageEvent}
\includegraphics[width=0.8\textwidth]{messageEvent}
\end{figure}

Die Simulationszeit hat den Typ simtime\_t. Im Listing \ref{lst:simtime} sind Beispiele beschrieben, auf welche Weise die aktuelle Zeit abgefragt werden kann und wie ein Event zu einem bestimmten Zeitpunkt ausgelöst werden kann. Dabei kann einfach ein beliebiger Wert als Verzögerung gewählt werden. Dieser wird zur momentanen Zeit addiert und dann wird der Event in Auftrag gegeben.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=C++,caption={Simulationszeit und Event},label=lst:simtime]
//get the simtime
simtime_t time = simTime();
//define a delay
simtime_t delay = 10.0;
//schedule an event at a given time
scheduleAt(simTime()+delay, event);
\end{lstlisting}
\end{minipage}

\paragraph{cArray} Ist eine Klasse, die als Sammlung für Objekte vom Typ cObject dient. Sie kommt zum Beispiel innerhalb der cMessage zum Einsatz. Die Parameterliste der Nachrichten besteht aus einem solchen cArray. Die wichtigsten Funktionen sind hier add() und remove(), die in Listing \ref{lst:carray} kurz an einem Beispiel gezeigt werden.

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=C++,caption={cArray add und remove},label=lst:carray]
//adding object
cMessage *newmsg = new cMessage("any name");
SimpleCoord *coord = new SimpleCoord("pos", position);
newmsg->getParList().add(coord);
send(newmsg, "toWorld$o");

//getting (and removing) objects
SimpleCoord *array = (SimpleCoord*) msg->getParList().remove(
"pos");
//double x = par->x;
//double y = par->y;
string name = msg->getName();
delete msg;
delete array;

\end{lstlisting}
\end{minipage}

Weiterhin gibt es noch Funktionen wie size(), find() oder clear(), die selbsterklärend sind. Neben remove() gibt es auch noch die Möglichkeit per get() auf Elemente zuzugreifen, ohne sie dabei sofort zu entfernen.

\section{MiXiM-Framework als Omnet++-Erweiterung}

\subsection{Einleitung}

MiXiM\cite{mixim} ist ein Framework welches die Funktionalität von Omnet++ in erster Linie um mobile und kabellose Knoten erweitert. Es implementiert einige Protokolle und stellt verschiedene Knoten bereit.\\
Außerdem fügt es zusätzlich auch nützliche Hilfsfunktionen zu Omnet++ hinzu, wie beispielsweise die FindModule-Klasse.

\subsection{Einige wichtige Module}

\subsubsection{FindModule}

Diese Klasse kann eine Instanz eines Objekts anhand eines Modulnamens finden. Es verhält sich daher wie eine Art Servicemanager. Mann kann mithilfe Dieser Submodule, globale Module, Hostmodule und Netzwerke finden. Dazu übergibt man einfach an ein Template wie in Beispiel \ref{lst:findmodule} den gewünschten Modulnamen und kann dann eine der Methoden, wie zum Beispiel findSubModule() aufrufen.

\begin{lstlisting}[language=C++, caption={Beispiel FindModule}, label=lst:findmodule]
//template der FindModule Klasse
template<typename T = cModule * const >
//Beispielverwendung
FindModule<BasePhyLayer*>::findSubModule(this)
\end{lstlisting}

\subsubsection{Coord}

Coord ist eine einfache Klasse zur Repräsentation von Koordinaten im 3-dimensionalen Raum. Es ist eine elementare Klasse für das MiXiM-Framework, da dieses Mobilität implementiert. Coord beinhaltet zusätzlich zu den 3-D-Koordinaten auch beispielsweise untere und obere Grenzen, Operatoren zum Rechnen und vergleichen und weitere Methoden wie zum Beispiel eine Distanzberechnung zwischen Koordinaten.

\subsubsection{Mobility}

Wie im vorherigen Abschnitt schon erwähnt ist die Mobilität eine der wichtigsten Funktionen, die das MiXiM-Framework bereitstellt. Es werden 4 verschiedene Arten von Bewegungen zur Verfügung gestellt, wobei eine davon, die LineSegmentMobilityBase, selbst wiederum viele verschiedene Varianten zur Verfügung stellt: 
\begin{itemize}
\item CircleMobility
\item LinearMobility
\item RectangleMobility
\item LineSegmentMobilityBase
\end{itemize}
Während die ersten 3 Arten sich von selbst erklären, ist dass bei der LineSegmentMobilityBase nicht der Fall. Es ist eine weitere Basisklasse für Bewegungsarten, welche aus einer Sequenz verschiedener linearer Bewegungen bestehen. Ein Beispiel ist die sogenannte TurtleMobility. Bei dieser kann ein Skript als XML-File hinterlegt werden, welches die Sequenz beschreibt. 
